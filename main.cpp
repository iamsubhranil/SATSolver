#include "codegen.h"
#include "display.h"
#include "engine.h"
#include "optimizer.h"
#include "parser.h"
#include "scanner.h"
#include <iostream>
#include <string.h>

using namespace std;

static void prefix(Parser *p, TokenType op, int prec) {
	p->registerParselet(op, new PrefixOperatorParselet(prec));
}

static void infixLeft(Parser *p, TokenType t, int prec) {
	p->registerParselet(t, new BinaryOperatorParselet(prec, false));
}

void registerParselets(Parser *p) {
	p->registerParselet(TOKEN_IDENTIFIER, new NameParselet());
	p->registerParselet(TOKEN_LEFT_PAREN, new GroupParselet());
	prefix(p, TOKEN_COMPLEMENT, Precedence::COMPLEMENT);

	infixLeft(p, TOKEN_OR, Precedence::OR);
	infixLeft(p, TOKEN_AND, Precedence::AND);
}

void solve(Scanner s, const char *name) {
	Parser p(s);
	registerParselets(&p);
	ExpressionPrinter ep(cout);
	ExpPtr            expression = p.parseExpression();
#ifdef DEBUG
	ep.print(expression.get());
	cout << "\n";
#endif
	CodeGenerator c;
	cout << "Generating bytecode..";
	Bytecode      b = c.generate(expression);
	cout << "\nNumber of variables : " << b->numSlots();
#ifdef DEBUG
	b->disassemble();
#endif
	cout << "\nOptimizing generated bytecode..";
	Optimizer::optimize(b);
	// b->disassemble();
	cout << "\nGenerating solutions..\n";
	clock_t start = clock();
	Resptr  satisfied = Engine::solve(b);
	clock_t end = clock() - start;
	cout << "Satisfied instances : " << satisfied->size();
	if(satisfied->size() > 0) {
		cout << "\nOne of them is : ";
		for(auto &val : *(satisfied.get())) {
			uintmax_t v = val;
			for(int j = 0; j < b->numSlots(); j++) {
				cout << ((v & 1) ? '1' : '0');
				v >>= 1;
			}
			break;
		}
	}
	cout << "\nelapsed: " << setprecision(6) << fixed
	     << ((double)end / CLOCKS_PER_SEC) << "\n";
	(void)name;
//#define SAT_SAVE_RESULT
#ifdef SAT_SAVE_RESULT
	int   lastbit = b->numSlots();
	char *result  = (char *)malloc(((lastbit + 1) * satisfied->size()) + 1);
	size_t k       = 0;
	for(auto &i : *satisfied.get()) {
		uintmax_t val = i;
		for(int j = 0; j < lastbit; j++) {
			result[k++] = ((val & (1 << j)) ? '1' : '0');
		}
		result[k++] = '\n';
	}
	result[k] = '\0';

	char *resname = (char *)malloc(strlen(name) + 8);
	snprintf(resname, strlen(name) + 8, "%s_results", name);
	FILE *f       = fopen(resname, "w");
	fprintf(f, "%s", result);
	fclose(f);
	free(resname);
	free(result);
#endif
}

int main(int argc, char **argv) {
	if(argc < 2) {
		err("Give the name of the file, or use '%s -g N' to randomly "
		    "generate and solve an SAT of N terms.",
		    argv[0]);
		return 1;
	}
	/*
	if(argc == 3 && strcmp(argv[1], "-g") == 0) {
	    char *end       = NULL;
	    long  noOfTerms = strtol(argv[1], &end, 10);
	    if(*end != '\0') {
	        err("Bad number of terms '%s'!", argv[1]);
	        return 2;
	    }
	    char *source = generate_sat(noOfTerms);
	} else*/
	if(argc == 2) {
		Scanner s(argv[1]);
		solve(s, argv[1]);
	} else {
		err("Give the name of the file, or use '%s -g N' to randomly "
		    "generate and solve an SAT of N terms.",
		    argv[0]);
		return 1;
	}
}
